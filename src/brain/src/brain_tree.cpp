#include <cmath>
#include <cstdlib>
#include <algorithm>
#include <cmath>
#include "brain_tree.h"
#include "locator.h"
#include "brain.h"
#include "utils/math.h"
#include "utils/print.h"
#include "utils/misc.h"
#include "locator.h"
#include "std_msgs/msg/string.hpp"
#include <fstream>
#include <ios>

/**
 * 这里使用宏定义来缩减 RegisterBuilder 的代码量
 * REGISTER_BUILDER(Test) 展开后的效果是
 * factory.registerBuilder<Test>(  \
 *      "Test",                    \
 *     [this](const string& name, const NodeConfig& config) { return make_unique<Test>(name, config, brain); });
 */
#define REGISTER_BUILDER(Name)     \
    factory.registerBuilder<Name>( \
        #Name,                     \
        [this](const string &name, const NodeConfig &config) { return make_unique<Name>(name, config, brain); });

void BrainTree::init()
{
    BehaviorTreeFactory factory;

    // Action Nodes
    REGISTER_BUILDER(RobotFindBall)
    REGISTER_BUILDER(Chase)
    REGISTER_BUILDER(SimpleChase)
    REGISTER_BUILDER(Adjust)
    REGISTER_BUILDER(Kick)
    REGISTER_BUILDER(StandStill)
    REGISTER_BUILDER(CalcKickDir)
    REGISTER_BUILDER(StrikerDecide)
    REGISTER_BUILDER(CamTrackBall)
    REGISTER_BUILDER(CamFindBall)
    REGISTER_BUILDER(CamFastScan)
    REGISTER_BUILDER(CamScanField)
    // REGISTER_BUILDER(SelfLocate)
    // REGISTER_BUILDER(SelfLocateEnterField)
    // REGISTER_BUILDER(SelfLocate1M)
    // REGISTER_BUILDER(SelfLocateBorder)
    // REGISTER_BUILDER(SelfLocate2T)
    // REGISTER_BUILDER(SelfLocateLT)
    // REGISTER_BUILDER(SelfLocatePT)
    // REGISTER_BUILDER(SelfLocate2X)
    REGISTER_BUILDER(SetVelocity)
    REGISTER_BUILDER(StepOnSpot)
    REGISTER_BUILDER(GoToFreekickPosition)
    REGISTER_BUILDER(GoToReadyPosition)
    REGISTER_BUILDER(GoToGoalBlockingPosition)
    REGISTER_BUILDER(TurnOnSpot)
    REGISTER_BUILDER(MoveToPoseOnField)
    REGISTER_BUILDER(GoBackInField)
    REGISTER_BUILDER(GoalieDecide)
    REGISTER_BUILDER(WaveHand)
    REGISTER_BUILDER(MoveHead)
    REGISTER_BUILDER(CheckAndStandUp)
    REGISTER_BUILDER(Assist)

    // 注册 Locator 相关的节点
    brain->registerLocatorNodes(factory);

    // Action Nodes for debug
    REGISTER_BUILDER(CalibrateOdom)
    REGISTER_BUILDER(PrintMsg)
    REGISTER_BUILDER(PlaySound)
    REGISTER_BUILDER(Speak)

    factory.registerBehaviorTreeFromFile(brain->config->treeFilePath);
    tree = factory.createTree("MainTree");

    // 构造完成后，初始化 blackboard entry
    initEntry();
}

void BrainTree::initEntry()
{
    setEntry<string>("player_role", brain->config->playerRole);
    setEntry<bool>("ball_location_known", false);
    setEntry<bool>("tm_ball_pos_reliable", false);
    setEntry<bool>("ball_out", false);
    setEntry<bool>("track_ball", true);
    setEntry<bool>("odom_calibrated", false);
    setEntry<string>("decision", "");
    setEntry<string>("defend_decision", "chase");
    setEntry<double>("ball_range", 0);

    setEntry<bool>("gamecontroller_isKickOff", true);
    setEntry<string>("gc_game_state", "");
    setEntry<string>("gc_game_sub_state_type", "NONE");
    setEntry<string>("gc_game_sub_state", "");
    setEntry<bool>("gc_is_kickoff_side", false);
    setEntry<bool>("gc_is_sub_state_kickoff_side", false);
    setEntry<bool>("gc_is_under_penalty", false);

    setEntry<bool>("need_check_behind", false);

    setEntry<bool>("is_lead", true); 
    setEntry<string>("goalie_mode", "attack"); 

    setEntry<int>("test_choice", 0);
    setEntry<int>("control_state", 0);
    setEntry<bool>("assist_chase", false);
    setEntry<bool>("assist_kick", false);
    setEntry<bool>("go_manual", false);

    setEntry<bool>("we_just_scored", false);
    setEntry<bool>("wait_for_opponent_kickoff", false);

    // 自动视觉校准相关
    setEntry<string>("calibrate_state", "pitch");
    setEntry<double>("calibrate_pitch_center", 0.0);
    setEntry<double>("calibrate_pitch_step", 1.0);
    setEntry<double>("calibrate_yaw_center", 0.0);
    setEntry<double>("calibrate_yaw_step", 1.0);
    setEntry<double>("calibrate_z_center", 0.0);
    setEntry<double>("calibrate_z_step", 0.01);
}

void BrainTree::tick()
{
    tree.tickOnce();
}

NodeStatus SetVelocity::tick()
{
    double x, y, theta;
    vector<double> targetVec;
    getInput("x", x);
    getInput("y", y);
    getInput("theta", theta);

    auto res = brain->client->setVelocity(x, y, theta);
    return NodeStatus::SUCCESS;
}

NodeStatus StepOnSpot::tick()
{
    std::srand(std::time(0));
    double vx = (std::rand() / (RAND_MAX / 0.02)) - 0.01;

    auto res = brain->client->setVelocity(vx, 0, 0);
    return NodeStatus::SUCCESS;
}

NodeStatus CamTrackBall::tick()
{
    double pitch, yaw, ballX, ballY, deltaX, deltaY;
    const double pixToleranceX = brain->config->camPixX / 4.; 
    const double pixToleranceY = brain->config->camPixY / 4.;
    const double xCenter = brain->config->camPixX / 2;
    const double yCenter = brain->config->camPixY / 2; 

    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/CamTrackBall", rerun::TextLog(msg));
    };
    auto logTrackingBox = [=](int color, string label) {
        brain->log->setTimeNow();
        vector<rerun::Vec2D> mins;
        vector<rerun::Vec2D> sizes;
        mins.push_back(rerun::Vec2D{xCenter - pixToleranceX, yCenter - pixToleranceY});
        sizes.push_back(rerun::Vec2D{pixToleranceX * 2, pixToleranceY * 2});
        brain->log->log(
            "image/track_ball",
            rerun::Boxes2D::from_mins_and_sizes(mins, sizes)
                .with_labels({label})
                .with_colors(color)
        );   

    };

    bool iSeeBall = brain->data->ballDetected;
    bool iKnowBallPos = brain->tree->getEntry<bool>("ball_location_known");
    bool tmBallPosReliable = brain->tree->getEntry<bool>("tm_ball_pos_reliable");
    if (!(iKnowBallPos || tmBallPosReliable))
        return NodeStatus::SUCCESS;

    if (!iSeeBall)
    { 
        if (iKnowBallPos) {
            pitch = brain->data->ball.pitchToRobot;
            yaw = brain->data->ball.yawToRobot;
        } else if (tmBallPosReliable) {
            pitch = brain->data->tmBall.pitchToRobot;
            yaw = brain->data->tmBall.yawToRobot;
        } else {
            log("reached impossible condition");
        }
        logTrackingBox(0x000000FF, "ball not detected"); 
    }
    else {      
        ballX = mean(brain->data->ball.boundingBox.xmax, brain->data->ball.boundingBox.xmin);
        ballY = mean(brain->data->ball.boundingBox.ymax, brain->data->ball.boundingBox.ymin);
        deltaX = ballX - xCenter;
        deltaY = ballY - yCenter; 
        
        if (std::fabs(deltaX) < pixToleranceX && std::fabs(deltaY) < pixToleranceY)
        {
            auto label = format("ballX: %.1f, ballY: %.1f, deltaX: %.1f, deltaY: %.1f", ballX, ballY, deltaX, deltaY);
            logTrackingBox(0x00FF00FF, label);
            return NodeStatus::SUCCESS;
        }

        double smoother = 1.5;
        double deltaYaw = deltaX / brain->config->camPixX * brain->config->camAngleX / smoother;
        double deltaPitch = deltaY / brain->config->camPixY * brain->config->camAngleY / smoother;

        pitch = brain->data->headPitch + deltaPitch;
        yaw = brain->data->headYaw - deltaYaw;
        auto label = format("ballX: %.1f, ballY: %.1f, deltaX: %.1f, deltaY: %.1f, pitch: %.1f, yaw: %.1f", ballX, ballY, deltaX, deltaY, pitch, yaw);
        logTrackingBox(0xFF0000FF, label);
    }

    brain->client->moveHead(pitch, yaw);
    return NodeStatus::SUCCESS;
}

CamFindBall::CamFindBall(const string &name, const NodeConfig &config, Brain *_brain) : SyncActionNode(name, config), brain(_brain)
{
    double lowPitch = 1.0;
    double highPitch = 0.45;
    double leftYaw = 1.1;
    double rightYaw = -1.1;

    _cmdSequence[0][0] = lowPitch;
    _cmdSequence[0][1] = leftYaw;
    _cmdSequence[1][0] = lowPitch;
    _cmdSequence[1][1] = 0;
    _cmdSequence[2][0] = lowPitch;
    _cmdSequence[2][1] = rightYaw;
    _cmdSequence[3][0] = highPitch;
    _cmdSequence[3][1] = rightYaw;
    _cmdSequence[4][0] = highPitch;
    _cmdSequence[4][1] = 0;
    _cmdSequence[5][0] = highPitch;
    _cmdSequence[5][1] = leftYaw;

    _cmdIndex = 0;
    _cmdIntervalMSec = 800;
    _cmdRestartIntervalMSec = 50000;
    _timeLastCmd = brain->get_clock()->now();
}

NodeStatus CamFindBall::tick()
{
    if (brain->data->ballDetected) {
        return NodeStatus::SUCCESS;
    }

    // 智能找球优化：如果是刚丢失球，重置扫描索引到球消失的方向
    // 检查时间差，防止很久以前的记忆干扰
    if (brain->msecsSince(brain->data->ball.timePoint) < 2000.0) { 
         double lastYaw = brain->data->ball.yawToRobot;
         // 假设 _cmdSequence[0] 是左边，[2] 是右边 (根据之前代码推断)
         // 0: 左下, 1: 中下, 2: 右下 ...
         if (lastYaw > 0.5) _cmdIndex = 0; // 优先扫左边
         else if (lastYaw < -0.5) _cmdIndex = 2; // 优先扫右边
         // 否则保持当前索引
    }

    auto curTime = brain->get_clock()->now();
    auto timeSinceLastCmd = (curTime - _timeLastCmd).nanoseconds() / 1e6;
    
    // 加快扫描速度
    if (timeSinceLastCmd < _cmdIntervalMSec) {
        return NodeStatus::SUCCESS;
    } 
    
    // 执行
    brain->client->moveHead(_cmdSequence[_cmdIndex][0], _cmdSequence[_cmdIndex][1]);
    
    // 索引循环
    size_t seqSize = sizeof(_cmdSequence) / sizeof(_cmdSequence[0]);
    _cmdIndex = (_cmdIndex + 1) % seqSize;
    _timeLastCmd = brain->get_clock()->now();
    
    return NodeStatus::SUCCESS;
}

NodeStatus CamScanField::tick()
{
    auto sec = brain->get_clock()->now().seconds();
    auto msec = static_cast<unsigned long long>(sec * 1000);
    double lowPitch, highPitch, leftYaw, rightYaw;
    getInput("low_pitch", lowPitch);
    getInput("high_pitch", highPitch);
    getInput("left_yaw", leftYaw);
    getInput("right_yaw", rightYaw);
    int msecCycle;
    getInput("msec_cycle", msecCycle);

    int cycleTime = msec % msecCycle;
    double pitch = cycleTime > (msecCycle / 2.0) ? lowPitch : highPitch;
    double yaw = cycleTime < (msecCycle / 2.0) ? (leftYaw - rightYaw) * (2.0 * cycleTime / msecCycle) + rightYaw : (leftYaw - rightYaw) * (2.0 * (msecCycle - cycleTime) / msecCycle) + rightYaw;

    brain->client->moveHead(pitch, yaw);
    return NodeStatus::SUCCESS;
}

NodeStatus Chase::tick()
{
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/Chase_Optimized", rerun::TextLog(msg));
    };

    double vxLimit, vyLimit, vthetaLimit, dist, safeDist;
    // 获取参数时增加 .value() 确保类型匹配，或者提供默认值
    if (!getInput("vx_limit", vxLimit)) vxLimit = 1.0;
    if (!getInput("vy_limit", vyLimit)) vyLimit = 0.5;
    if (!getInput("vtheta_limit", vthetaLimit)) vthetaLimit = 1.0;
    if (!getInput("dist", dist)) dist = 0.2;
    if (!getInput("safe_dist", safeDist)) safeDist = 0.5;

    // 1. 获取基础数据
    auto ballPos = brain->data->ball.posToField;
    auto robotPose = brain->data->robotPoseToField;
    double kickDir = brain->data->kickDir; 
    
    // 2. 坐标系转换：计算机器人相对于“理想踢球坐标系”的误差
    // 理想位置：球的后方 dist 处，朝向 kickDir
    // 坐标系定义：原点在球，X轴指向 kickDir，Y轴垂直于 kickDir 向左
    
    double dx_global = robotPose.x - ballPos.x;
    double dy_global = robotPose.y - ballPos.y;

    // 将全局相对坐标 (dx, dy) 旋转到 踢球坐标系
    // Rotation Matrix R(-kickDir):
    // [ cos  sin ]
    // [ -sin cos ]
    double local_x = dx_global * cos(kickDir) + dy_global * sin(kickDir);
    double local_y = -dx_global * sin(kickDir) + dy_global * cos(kickDir);
    double local_theta = toPInPI(robotPose.theta - kickDir); // 角度误差

    // 3. 设定目标 (在踢球坐标系下)
    // 我们希望机器人在 X = -dist (球后), Y = 0 (正对), Theta = 0 (朝向一致)
    // 限制 target_x_kick 至少在球后方一定距离，给冲刺留空间
    double target_x_kick = -std::max(dist, 0.25); 
    
    // 4. 计算控制量 (在踢球坐标系下的期望速度)
    double kp_x = 1.8; // 稍微增大 P 参数
    double kp_y = 2.5; // 横向纠偏增益大，保证对齐
    double kp_theta = 2.8;

    double v_x_kick = -kp_x * (local_x - target_x_kick);
    double v_y_kick = -kp_y * local_y; 
    
    // 5. 关键优化：根据“对齐程度”限制纵向速度 (Throttling)
    // 如果横向偏离大(abs(local_y)) 或 角度偏离大(abs(local_theta))，则减慢前进速度 v_x
    // 这迫使机器人在没对准时“横移”而不是“冲锋”
    double alignment_error = std::fabs(local_y) * 1.5 + std::fabs(local_theta) * 0.5;
    // 使用 std::max 确保因子不小于 0.1，避免完全卡死
    double throttle_factor = std::max(0.1, 1.0 - alignment_error); 
    
    // 只有在球后方（准备射门阶段）才限制速度；如果跑过了或者在绕后，不限制
    if (local_x < 0.1) {
        v_x_kick *= throttle_factor;
    }

    // 6. 速度坐标变换：从 踢球坐标系 -> 机器人坐标系
    // V_robot = Rot(-local_theta) * V_kick
    // 注意：这里 local_theta = robot - kickDir，所以 kickDir = robot - local_theta
    // 实际上我们需要把 V_kick (相对于 kickDir) 转换成 V_robot (相对于 robot)
    // 旋转角度应该是 -local_theta
    double vx = v_x_kick * cos(local_theta) + v_y_kick * sin(local_theta); // sin(-a) = -sin(a) -> logic fix
    double vy = -v_x_kick * sin(local_theta) + v_y_kick * cos(local_theta); 
    double vtheta = -kp_theta * local_theta;

    // 7. 绕后逻辑补充 (Circle Logic)
    // 如果机器人在球的前方 (local_x > 0) 或者侧方很远，上述逻辑可能会导致撞球
    // 增加一个简单的势场绕行
    if (local_x > -0.15 || std::fabs(local_y) > 0.4) {
        // 目标点是球后方 safe_dist 处
        double target_global_x = ballPos.x - safeDist * cos(kickDir);
        double target_global_y = ballPos.y - safeDist * sin(kickDir);
        
        // 简单的 P 控制去安全点
        double err_x = target_global_x - robotPose.x;
        double err_y = target_global_y - robotPose.y;
        
        // 转换到机器人坐标系
        double target_dir_global = atan2(err_y, err_x);
        double dir_diff = toPInPI(target_dir_global - robotPose.theta);
        double dist_to_target = std::hypot(err_x, err_y);
        
        // 简单的极坐标控制
        vx = vxLimit; 
        vy = 0; // 主要靠前向速度
        vtheta = dir_diff * 2.5;

        // 如果角度偏差大，减小 vx，原地转
        if (std::fabs(dir_diff) > 0.5) vx = 0.0;
        else if (std::fabs(dir_diff) > 0.2) vx *= 0.5;
    }

    // 8. 射门触发逻辑 (Zero-Stop Kick)
    // 条件变得更严格：距离合适，且角度误差极小，且横向误差极小
    bool distOk = (local_x > -0.45) && (local_x < 0.1); // 在球后方不远处
    bool angleOk = std::fabs(local_theta) < 0.15; // 角度误差 < 8.5度
    bool yOk = std::fabs(local_y) < 0.12; // 横向偏离 < 12cm

    if (distOk && angleOk && yOk) {
        brain->tree->setEntry<string>("decision", "kick");
        brain->speak("Shoot", false);
        log("Precision kick triggered!");
    }

    // 9. 限幅与避障
    vx = cap(vx, vxLimit, -vxLimit);
    vy = cap(vy, vyLimit, -vyLimit);
    vtheta = cap(vtheta, vthetaLimit, -vthetaLimit);

    // 避障逻辑
    bool avoidObstacle = false;
    brain->get_parameter("obstacle_avoidance.avoid_during_chase", avoidObstacle);
    double oaSafeDist = 0.5;
    brain->get_parameter("obstacle_avoidance.chase_ao_safe_dist", oaSafeDist);
    
    if (avoidObstacle) {
        double moveDir = atan2(vy, vx);
        // distToObstacle 在 brain.h 中声明
        if (brain->distToObstacle(moveDir) < oaSafeDist) {
             vy += (vy > 0 ? 0.3 : -0.3); // 侧向闪躲
             vx *= 0.5; // 减速
        }
    }

    // 10. 平滑处理 (可选，防止电机抖动)
    static double lastVx = 0, lastVy = 0, lastVtheta = 0;
    double alpha = 0.7; // 0.7 新值
    vx = alpha * vx + (1 - alpha) * lastVx;
    vy = alpha * vy + (1 - alpha) * lastVy;
    vtheta = alpha * vtheta + (1 - alpha) * lastVtheta;
    lastVx = vx; lastVy = vy; lastVtheta = vtheta;

    brain->client->setVelocity(vx, vy, vtheta, false, false, false);
    
    // 可视化
    brain->log->setTimeNow();
    brain->log->log(
        "field/chase_target", 
        rerun::Arrows2D::from_vectors({{cos(kickDir), sin(kickDir)}})
        .with_origins({{ballPos.x - dist*cos(kickDir), ballPos.y - dist*sin(kickDir)}})
        .with_colors({0x00FF00FF})
    );

    return NodeStatus::SUCCESS;
}

NodeStatus SimpleChase::tick()
{
    double stopDist, stopAngle, vyLimit, vxLimit;
    getInput("stop_dist", stopDist);
    getInput("stop_angle", stopAngle);
    getInput("vx_limit", vxLimit);
    getInput("vy_limit", vyLimit);

    if (!brain->tree->getEntry<bool>("ball_location_known"))
    {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    double vx = brain->data->ball.posToRobot.x;
    double vy = brain->data->ball.posToRobot.y;
    double vtheta = brain->data->ball.yawToRobot * 4.0; 

    double linearFactor = 1 / (1 + exp(3 * (brain->data->ball.range * fabs(brain->data->ball.yawToRobot)) - 3)); 
    vx *= linearFactor;
    vy *= linearFactor;

    vx = cap(vx, vxLimit, -1.0);    
    vy = cap(vy, vyLimit, -vyLimit); 

    if (brain->data->ball.range < stopDist)
    {
        vx = 0;
        vy = 0;
        // if (fabs(brain->data->ball.yawToRobot) < stopAngle) vtheta = 0; 
    }

    brain->client->setVelocity(vx, vy, vtheta, false, false, false);
    return NodeStatus::SUCCESS;
}


NodeStatus GoToFreekickPosition::onStart() {
    // brain->log->log("debug/freekick_position/onStart", rerun::TextLog(format("stage onStart")));
    _isInFinalAdjust = false;
    return NodeStatus::RUNNING;
}

NodeStatus GoToFreekickPosition::onRunning() {
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/GoToFreekickPosition", rerun::TextLog(msg));
    };
    log("running");


    string side;
    getInput("side", side);
    if (side !="attack" && side != "defense") return NodeStatus::SUCCESS;
    
    Pose2D targetPose;
    auto fd = brain->config->fieldDimensions;
    auto ballPos = brain->data->ball.posToField;
    auto robotPose = brain->data->robotPoseToField;

    if (side == "attack") {
        double targetDir = brain->data->kickDir;
       double dist;
       getInput("attack_dist", dist);

       targetPose.x = ballPos.x - dist * cos(targetDir);
       targetPose.y = ballPos.y - dist * sin(targetDir);
       targetPose.theta = targetDir;

        if (brain->config->numOfPlayers == 3 && brain->data->liveCount >= 2)
        {
            if (!brain->isPrimaryStriker()) {
                targetPose.y = 0;
                targetPose.x -= 1.5;
                if (targetPose.x < -fd.length / 2.0 + fd.goalAreaLength) targetPose.x = -fd.length / 2.0 + fd.goalAreaLength;
                auto buffer = 2.0;
                auto targetXPose = brain->config->fieldDimensions.length / 2 - buffer;
                if (targetPose.x > targetXPose) {
                    targetPose.x = targetXPose;
                    targetPose.theta = 0;
                }
            }
        }

    } else if (side == "defense") {
        double targetDir = atan2(ballPos.y, ballPos.x + fd.length / 2);
        double dist;
        getInput("defense_dist", dist);
        targetPose.x = ballPos.x - dist * cos(targetDir);
        targetPose.y = ballPos.y - dist * sin(targetDir);
        targetPose.theta = targetDir;
        if (ballPos.x < -fd.length / 2 + 1.0)  targetPose.x = -fd.length / 2 + 1.5;

        if (brain->config->numOfPlayers == 3 && brain->data->liveCount >= 2)
        {
            if (!brain->isPrimaryStriker()) {
                targetPose.y = targetPose.y > 0 ? targetPose.y - 1.0 : targetPose.y + 1.0;
            }
        }
    }

    double dist = norm(targetPose.x - robotPose.x, targetPose.y - robotPose.y);
    double deltaDir = toPInPI(targetPose.theta - robotPose.theta);


    if ( 
        dist < 0.2 
        && fabs(deltaDir) < 0.1
    ) {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    if (!brain->get_parameter("obstacle_avoidance.enable_freekick_avoid").as_bool() || dist < 1.0 || _isInFinalAdjust) {
        _isInFinalAdjust = true; 
        auto targetPose_r = brain->data->field2robot(targetPose);

        double vx = targetPose_r.x;
        double vy = targetPose_r.y;
        double vtheta = brain->data->ball.yawToRobot * 4.0; 

        double linearFactor = 1 / (1 + exp(3 * (brain->data->ball.range * fabs(brain->data->ball.yawToRobot)) - 3)); 
        vx *= linearFactor;
        vy *= linearFactor;


        Line path = {robotPose.x, robotPose.y, targetPose.x, targetPose.y};
        if (
            pointMinDistToLine(Point2D({ballPos.x, ballPos.y}), path) < 0.5
            && brain->data->ball.range < 1.0
        ) {
            vx = min(0.0, vx);
            vy = vy >= 0 ? vy + 0.1: vy - 0.1;
        }

        double vxLimit, vyLimit;
        getInput("vx_limit", vxLimit);
        getInput("vy_limit", vyLimit);
        vx = cap(vx, vxLimit, -1.0);    
        vy = cap(vy, vyLimit, -vyLimit);    
        

        brain->client->setVelocity(vx, vy, vtheta, false, false, false);
        return NodeStatus::RUNNING;
    }

    double longRangeThreshold = 1.0;
    double turnThreshold = 0.4;
    double vxLimit = 0.6;
    double vyLimit = 0.5;
    double vthetaLimit = 1.5;
    bool avoidObstacle = true;
    // brain->log->log("debug/freekick_position", rerun::TextLog(format("stage move: targetPose: (%.2f, %.2f, %.2f)", targetPose.x, targetPose.y, targetPose.theta)));
    brain->client->moveToPoseOnField3(targetPose.x, targetPose.y, targetPose.theta, longRangeThreshold, turnThreshold, vxLimit, vyLimit, vthetaLimit, 0.2, 0.2, 0.1, avoidObstacle);

    return NodeStatus::RUNNING;
}

void GoToFreekickPosition::onHalted() {
    // brain->log->log("debug/freekick_position/onHault", rerun::TextLog(format("stage OnHalted")));
}

NodeStatus GoToGoalBlockingPosition::tick() {
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/Goalie_Predict", rerun::TextLog(msg));
    };

    double distTolerance = getInput<double>("dist_tolerance").value();
    double thetaTolerance = getInput<double>("theta_tolerance").value();
    double distToGoalline = getInput<double>("dist_to_goalline").value();

    auto fd = brain->config->fieldDimensions;
    auto ballPos = brain->data->ball.posToField;
    auto robotPose = brain->data->robotPoseToField;

    // 1. 计算目标 X 坐标 (站在球门线上前方一点)
    // 守门员通常站在 -Length/2 + 0.5m 处
    double targetX = -fd.length / 2.0 + distToGoalline;

    // 2. 速度估计与轨迹预测 (核心优化)
    static Point2D lastBallPos = {0,0};
    static rclcpp::Time lastTime = brain->get_clock()->now();
    auto now = brain->get_clock()->now();
    double dt = (now - lastTime).seconds();
    
    double predY = ballPos.y; // 默认：球当前的Y

    // 只有当 dt 合理且球在移动时才预测
    if (dt > 0.05 && dt < 1.0) {
        double vx = (ballPos.x - lastBallPos.x) / dt;
        double vy = (ballPos.y - lastBallPos.y) / dt;
        
        // 只有球向我方球门移动 (vx < 0) 且速度够快时才预测
        if (vx < -0.2) {
            // 计算球到达球门线的时间
            double timeToGoal = (targetX - ballPos.x) / vx;
            
            // 限制预测时间在未来 2秒内，太远就不准了
            if (timeToGoal > 0 && timeToGoal < 2.0) {
                predY = ballPos.y + vy * timeToGoal;
                log(format("Predicting save at Y=%.2f (t=%.2fs)", predY, timeToGoal));
            }
        }
    }
    
    // 更新历史数据
    if (dt > 0.05) {
        lastBallPos = ballPos;
        lastTime = now;
    }

    // 3. 目标 Y 坐标 (限制在球门范围内)
    // 稍微收缩防守范围，防止撞柱子
    double maxY = fd.goalWidth / 2.0 - 0.2;
    double targetY = cap(predY, maxY, -maxY);

    Pose2D targetPose{targetX, targetY, 0.0};
    
    // 守门员始终朝向球
    double targetTheta = atan2(ballPos.y - robotPose.y, ballPos.x - robotPose.x);
    
    // 4. 移动控制
    double dist = norm(targetPose.x - robotPose.x, targetPose.y - robotPose.y);
    if (dist < distTolerance && fabs(toPInPI(robotPose.theta - targetTheta)) < thetaTolerance) {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    // 使用场地位姿控制
    brain->client->moveToPoseOnField2(
        targetPose.x, targetPose.y, targetTheta, 
        1.0, 0.5, // 宽松的参数
        1.0, 0.6, 1.5, // 速度限制：守门员横移要快 (vy=0.6)
        distTolerance/2, distTolerance/2, thetaTolerance, 
        false // 守门员通常不需要避障，直接到位
    );
    
    // 可视化预测点
    brain->log->setTimeNow();
    brain->log->logBall("field/goalie_target", Point({targetPose.x, targetPose.y, 0}), 0x0000FFFF, false, false);

    return NodeStatus::SUCCESS;
}

NodeStatus Assist::tick() {
    // 日志
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/Assist_Pro", rerun::TextLog(msg));
    };

    double distTolerance = getInput<double>("dist_tolerance").value();
    double thetaTolerance = getInput<double>("theta_tolerance").value();
    // double distToGoalline = getInput<double>("dist_to_goalline").value(); // 暂时不用，用动态边界

    auto fd = brain->config->fieldDimensions;
    auto ballPos = brain->data->ball.posToField;
    auto robotPose = brain->data->robotPoseToField;

    // ==========================================
    // 1. 团队角色分配 (保留原代码逻辑)
    // ==========================================
    bool isSecondary = false; 
    int selfIdx = brain->config->playerId - 1;
    
    // 简单的协作逻辑：如果有一个队友也是 Striker 且他在我前面，那我是副手
    for (int i = 0; i < HL_MAX_NUM_PLAYERS; i++) {
        if (i == selfIdx) continue; 

        auto tmStatus = brain->data->tmStatus[i];
        if (!tmStatus.isAlive) continue; 
        if (tmStatus.isLead) continue; // 队长通常是持球者
        // if (tmStatus.role != "striker") continue; // 如果你们策略里所有人都是 striker

        // 判定条件：如果队友离球门更近（进攻方向x更大），或者离球更近
        // 这里沿用你的简单判定：谁 x 大谁是主助攻（更靠前接应）
        if (tmStatus.robotPoseToField.x > robotPose.x) {
            isSecondary = true; 
        }
    }
    log(format("Role: %s", isSecondary ? "Secondary (Back)" : "Primary (Front)"));

    // ==========================================
    // 2. 战术站位计算 (三角进攻优化)
    // ==========================================
    Pose2D targetPose;
    
    // 策略：
    // 主助攻 (Primary): 去球的“弱侧”接应（球在左他就去右），形成交叉传球路线。
    // 副助攻 (Secondary): 去球的“强侧”保护，或者拖后防止反击。
    
    double sideSign = (ballPos.y > 0) ? -1.0 : 1.0; // 球在左(>0)，弱侧是右(-1)

    if (!isSecondary) {
        // 主力：去弱侧，靠前一点
        targetPose.x = ballPos.x - 1.5; 
        targetPose.y = ballPos.y + sideSign * 2.5; 
    } else {
        // 副手：去强侧(同侧)，或者拖在正后方保护
        // 选择拖后保护更稳妥
        targetPose.x = ballPos.x - 3.5; 
        targetPose.y = ballPos.y * 0.5; // 稍微向中间靠
    }

    // 边界限制 (Smart Clamping)
    double safeMargin = 0.8;
    // 1. 场宽限制
    targetPose.y = std::max(-fd.width/2 + safeMargin, std::min(fd.width/2 - safeMargin, targetPose.y));
    // 2. 场长限制 (不退到底线外，也不冲进对方禁区太深)
    targetPose.x = std::max(-fd.length/2 + 0.6, targetPose.x);
    if (targetPose.x > fd.length/2 - fd.goalAreaLength) targetPose.x = fd.length/2 - fd.goalAreaLength;

    // 朝向：始终看向球
    targetPose.theta = atan2(ballPos.y - targetPose.y, ballPos.x - targetPose.x);

    // ==========================================
    // 3. 运动控制 (P控制 + 势场避障)
    // ==========================================
    double dist = std::hypot(targetPose.x - robotPose.x, targetPose.y - robotPose.y);
    double errTheta = toPInPI(targetPose.theta - robotPose.theta);

    // 到位判断
    if (dist < distTolerance && std::fabs(errTheta) < thetaTolerance) {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    // 基础速度 (P Control)
    double kp = 1.2;
    double v_gx = kp * (targetPose.x - robotPose.x);
    double v_gy = kp * (targetPose.y - robotPose.y);
    
    // 避障 (Potential Field) - 替代原有的 calculateAvoidDir
    // 这是一个更平滑的算法，会产生一个推力把机器人推离障碍物
    double rep_force_x = 0;
    double rep_force_y = 0;
    
    // 检查球作为障碍物 (防止踩球)
    double distToBall = std::hypot(robotPose.x - ballPos.x, robotPose.y - ballPos.y);
    if (distToBall < 0.6) { // 0.6米内避让球
        double force = 1.0 * (1.0/distToBall - 1.0/0.6);
        rep_force_x += force * (robotPose.x - ballPos.x) / distToBall;
        rep_force_y += force * (robotPose.y - ballPos.y) / distToBall;
    }

    // 检查其他障碍物 (如果有数据)
    // 假设 brain->data->getObstacles() 可用，如果不可用可以注释掉
    /* for (const auto& obs : brain->data->getObstacles()) {
        double d = std::hypot(robotPose.x - obs.posToField.x, robotPose.y - obs.posToField.y);
        if (d < 0.6) {
             double force = 0.8 * (1.0/d - 1.0/0.6);
             rep_force_x += force * (robotPose.x - obs.posToField.x) / d;
             rep_force_y += force * (robotPose.y - obs.posToField.y) / d;
        }
    }
    */

    // 叠加避障力
    v_gx += rep_force_x;
    v_gy += rep_force_y;

    // 转为机器人坐标系
    double vx = v_gx * cos(robotPose.theta) + v_gy * sin(robotPose.theta);
    double vy = -v_gx * sin(robotPose.theta) + v_gy * cos(robotPose.theta);
    double vtheta = 1.5 * errTheta;

    // 限幅 (Speed Limit)
    double vxLimit, vyLimit;
    if (!getInput("vx_limit", vxLimit)) vxLimit = 1.0;
    if (!getInput("vy_limit", vyLimit)) vyLimit = 0.6;
    
    vx = cap(vx, vxLimit, -vxLimit);
    vy = cap(vy, vyLimit, -vyLimit);
    vtheta = cap(vtheta, 1.5, -1.5);

    // 执行
    brain->client->setVelocity(vx, vy, vtheta, false, false, false);
    
    // 可视化
    brain->log->setTimeNow();
    brain->log->logBall("field/assist_target", Point({targetPose.x, targetPose.y, 0}), isSecondary ? 0xCCCCCCFF : 0xFFFF00FF, false, false);

    return NodeStatus::SUCCESS;
}

NodeStatus Adjust::tick()
{
    auto log = [=](string msg) { 
        brain->log->setTimeNow();
        brain->log->log("debug/adjust5", rerun::TextLog(msg)); 
    };
    log("enter");
    if (!brain->tree->getEntry<bool>("ball_location_known"))
    {
        return NodeStatus::SUCCESS;
    }

    double turnThreshold, vxLimit, vyLimit, vthetaLimit, range, st_far, st_near, vtheta_factor, NEAR_THRESHOLD;
    getInput("near_threshold", NEAR_THRESHOLD);
    getInput("tangential_speed_far", st_far);
    getInput("tangential_speed_near", st_near);
    getInput("vtheta_factor", vtheta_factor);
    getInput("turn_threshold", turnThreshold);
    getInput("vx_limit", vxLimit);
    getInput("vy_limit", vyLimit);
    getInput("vtheta_limit", vthetaLimit);
    getInput("range", range);
    log(format("ballX: %.1f ballY: %.1f ballYaw: %.1f", brain->data->ball.posToRobot.x, brain->data->ball.posToRobot.y, brain->data->ball.yawToRobot));
    double NO_TURN_THRESHOLD, TURN_FIRST_THRESHOLD;
    getInput("no_turn_threshold", NO_TURN_THRESHOLD);
    getInput("turn_first_threshold", TURN_FIRST_THRESHOLD);


    double vx = 0, vy = 0, vtheta = 0;
    double kickDir = brain->data->kickDir;
    double dir_rb_f = brain->data->robotBallAngleToField; 
    double deltaDir = toPInPI(kickDir - dir_rb_f);
    double ballRange = brain->data->ball.range;
    double ballYaw = brain->data->ball.yawToRobot;
    // double st = cap(fabs(deltaDir), st_far, st_near);
    double st = st_far; 
    double R = ballRange; 
    double r = range;
    double sr = cap(R - r, 0.5, 0); 
    log(format("R: %.2f, r: %.2f, sr: %.2f", R, r, sr));

    log(format("deltaDir = %.1f", deltaDir));
    if (fabs(deltaDir) * R < NEAR_THRESHOLD) {
        log("use near speed");
        st = st_near;
        // sr = 0.;
        // vxLimit = 0.1;
    }

    double theta_robot_f = brain->data->robotPoseToField.theta; 
    double thetat_r = dir_rb_f + M_PI / 2 * (deltaDir > 0 ? -1.0 : 1.0) - theta_robot_f; 
    double thetar_r = dir_rb_f - theta_robot_f; 

    vx = st * cos(thetat_r) + sr * cos(thetar_r); 
    vy = st * sin(thetat_r) + sr * sin(thetar_r); 
    // vtheta = toPInPI(ballYaw + st / R * (deltaDir > 0 ? 1.0 : -1.0)); 
    vtheta = ballYaw;
    vtheta *= vtheta_factor; 

    if (fabs(ballYaw) < NO_TURN_THRESHOLD) vtheta = 0.; 
    if (
        fabs(ballYaw) > TURN_FIRST_THRESHOLD 
        && fabs(deltaDir) < M_PI / 4
    ) { 
        vx = 0;
        vy = 0;
    }

    vx = cap(vx, vxLimit, -0.);
    vy = cap(vy, vyLimit, -vyLimit);
    vtheta = cap(vtheta, vthetaLimit, -vthetaLimit);
    
    log(format("vx: %.1f vy: %.1f vtheta: %.1f", vx, vy, vtheta));
    brain->client->setVelocity(vx, vy, vtheta);
    return NodeStatus::SUCCESS;
}

NodeStatus CalcKickDir::tick()
{
    double crossThreshold;
    if (!getInput("cross_threshold", crossThreshold)) crossThreshold = 0.5;

    auto gpAngles = brain->getGoalPostAngles(0.0);
    double thetal = gpAngles[0]; 
    double thetar = gpAngles[1];
    auto bPos = brain->data->ball.posToField;
    auto fd = brain->config->fieldDimensions;
    uint32_t color = 0xFFFFFFFF; 

    // 默认策略：向球门射门
    string kickType = "shoot";
    // 射向球门中心
    double kickDir = atan2(-bPos.y, fd.length/2 - bPos.x);

    // 1. 判断是否被封堵 (射门角度太小)
    bool isBlocked = (std::fabs(thetal - thetar) < 0.2); // 0.2 rad 约 11度

    // 2. 智能传球逻辑 (Smart Passing)
    // 只有当有队友且被封堵时才考虑传球
    if (isBlocked && brain->config->numOfPlayers > 1) {
        int bestTmIdx = -1;
        double maxScore = -100.0;

        for (int i = 0; i < HL_MAX_NUM_PLAYERS; i++) {
            // 跳过自己
            if (i == (brain->config->playerId - 1)) continue;
            // 跳过掉线的队友 (HL_MAX_NUM_PLAYERS 是宏，i 是 int，安全)
            if (!brain->data->tmStatus[i].isAlive) continue;

            auto tmPose = brain->data->tmStatus[i].robotPoseToField;
            
            // 评分标准:
            // 1. x 越大越好 (越靠前)
            // 2. 距离不要太远 ( > 5米传球精度不够)
            double distToTm = std::hypot(tmPose.x - bPos.x, tmPose.y - bPos.y);
            
            double score = tmPose.x * 2.0; 
            if (distToTm > 5.0) score -= 10.0; // 太远扣分
            if (distToTm < 1.0) score -= 5.0;  // 太近没意义

            // 如果队友在身后，极大扣分
            if (tmPose.x < bPos.x) score -= 5.0;

            if (score > maxScore) {
                maxScore = score;
                bestTmIdx = i;
            }
        }

        // 阈值判断：分数必须大于一定值才传球
        if (bestTmIdx != -1 && maxScore > -5.0) {
            kickType = "pass"; 
            // 传球给该队友
            auto target = brain->data->tmStatus[bestTmIdx].robotPoseToField;
            kickDir = atan2(target.y - bPos.y, target.x - bPos.x);
            color = 0x0000FFFF; // 蓝色代表传球
            brain->speak("Passing", false);
        }
    }

    // 3. 常规逻辑修正 (Cross / Block / Shoot修正)
    if (kickType == "shoot") { 
        if (thetal - thetar < crossThreshold && bPos.x > fd.circleRadius) {
            kickType = "cross"; // 传中/底线回敲
            color = 0xFF00FFFF;
            kickDir = atan2(-bPos.y, fd.length/2 - fd.penaltyDist/2 - bPos.x);
        }
        else if (brain->isDefensing()) {
            kickType = "block"; // 防守解围
            color = 0xFFFF00FF;
            // 往两边踢，或者往前踢
            kickDir = atan2(bPos.y, bPos.x + fd.length/2);
        }
        
        // 强制修正：如果已经带球过半场且接近底线，角度不能太偏
        if (bPos.x > fd.length / 2) kickDir = 0;
    }

    brain->data->kickType = kickType;
    brain->data->kickDir = kickDir;

    // 可视化
    brain->log->setTimeNow();
    brain->log->log(
        "field/kick_dir",
        rerun::Arrows2D::from_vectors({{1.0 * cos(kickDir), -1.0 * sin(kickDir)}})
            .with_origins({{bPos.x, -bPos.y}})
            .with_colors({color})
            .with_radii(0.02)
            .with_draw_order(31)
    );

    return NodeStatus::SUCCESS;
}

NodeStatus StrikerDecide::tick() {
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/striker_decide", rerun::TextLog(msg));
    };

    double chaseRangeThreshold;
    getInput("chase_threshold", chaseRangeThreshold);
    string lastDecision, position;
    getInput("decision_in", lastDecision);
    getInput("position", position);

    double kickDir = brain->data->kickDir;
    double dir_rb_f = brain->data->robotBallAngleToField; 
    auto ball = brain->data->ball;
    double ballRange = ball.range;
    double ballYaw = ball.yawToRobot;
    double ballX = ball.posToRobot.x;
    double ballY = ball.posToRobot.y;
    
    const double goalpostMargin = 0.3; 
    bool angleGoodForKick = brain->isAngleGood(goalpostMargin, "kick");

    bool avoidPushing;
    double kickAoSafeDist;
    brain->get_parameter("obstacle_avoidance.avoid_during_kick", avoidPushing);
    brain->get_parameter("obstacle_avoidance.kick_ao_safe_dist", kickAoSafeDist);
    bool avoidKick = avoidPushing 
        && brain->data->robotPoseToField.x < brain->config->fieldDimensions.length / 2 - brain->config->fieldDimensions.goalAreaLength
        && brain->distToObstacle(brain->data->ball.yawToRobot) < kickAoSafeDist;

    log(format("ballRange: %.2f, ballYaw: %.2f, ballX:%.2f, ballY: %.2f kickDir: %.2f, dir_rb_f: %.2f, angleGoodForKick: %d",
        ballRange, ballYaw, ballX, ballY, kickDir, dir_rb_f, angleGoodForKick));

    
    double deltaDir = toPInPI(kickDir - dir_rb_f);
    auto now = brain->get_clock()->now();
    auto dt = brain->msecsSince(timeLastTick);
    bool reachedKickDir = 
        deltaDir * lastDeltaDir <= 0 
        && fabs(deltaDir) < M_PI / 6
        && dt < 100;
    reachedKickDir = reachedKickDir || fabs(deltaDir) < 0.1;
    timeLastTick = now;
    lastDeltaDir = deltaDir;

    string newDecision;
    auto color = 0xFFFFFFFF; 
    bool iKnowBallPos = brain->tree->getEntry<bool>("ball_location_known");
    bool tmBallPosReliable = brain->tree->getEntry<bool>("tm_ball_pos_reliable");
    if (!(iKnowBallPos || tmBallPosReliable))
    {
        newDecision = "find";
        color = 0xFFFFFFFF;
    } else if (!brain->data->tmImLead) {
        newDecision = "assist";
        color = 0x00FFFFFF;
    } else if (ballRange > chaseRangeThreshold * (lastDecision == "chase" ? 0.9 : 1.0))
    {
        newDecision = "chase";
        color = 0x0000FFFF;
    } else if (
        (
            (angleGoodForKick && !brain->data->isFreekickKickingOff) 
            || reachedKickDir
        )
        && brain->data->ballDetected
        && fabs(brain->data->ball.yawToRobot) < M_PI / 2.
        && !avoidKick
        && ball.range < 1.5
    ) {
        if (brain->data->kickType == "cross") newDecision = "cross";
        else newDecision = "kick";      
        color = 0x00FF00FF;
        brain->data->isFreekickKickingOff = false; 
    }
    else
    {
        newDecision = "adjust";
        color = 0xFFFF00FF;
    }

    setOutput("decision_out", newDecision);
    brain->log->logToScreen(
        "tree/Decide",
        format(
            "Decision: %s ballrange: %.2f ballyaw: %.2f kickDir: %.2f rbDir: %.2f angleGoodForKick: %d lead: %d", 
            newDecision.c_str(), ballRange, ballYaw, kickDir, dir_rb_f, angleGoodForKick, brain->data->tmImLead
        ),
        color
    );
    return NodeStatus::SUCCESS;
}

NodeStatus GoalieDecide::tick()
{

    double chaseRangeThreshold;
    getInput("chase_threshold", chaseRangeThreshold);
    string lastDecision, position;
    getInput("decision_in", lastDecision);

    double kickDir = atan2(brain->data->ball.posToField.y, brain->data->ball.posToField.x + brain->config->fieldDimensions.length / 2);
    double dir_rb_f = brain->data->robotBallAngleToField;
    auto goalPostAngles = brain->getGoalPostAngles(0.3);
    double theta_l = goalPostAngles[0]; 
    double theta_r = goalPostAngles[1]; 
    bool angleIsGood = (dir_rb_f > -M_PI / 2 && dir_rb_f < M_PI / 2);
    double ballRange = brain->data->ball.range;
    double ballYaw = brain->data->ball.yawToRobot;

    string newDecision;
    auto color = 0xFFFFFFFF; 
    bool iKnowBallPos = brain->tree->getEntry<bool>("ball_location_known");
    bool tmBallPosReliable = brain->tree->getEntry<bool>("tm_ball_pos_reliable");
    if (!(iKnowBallPos || tmBallPosReliable))
    {
        newDecision = "find";
        color = 0x0000FFFF;
    }
    else if (brain->data->ball.posToField.x > 0 - static_cast<double>(lastDecision == "retreat"))
    {
        newDecision = "retreat";
        color = 0xFF00FFFF;
    } else if (ballRange > chaseRangeThreshold * (lastDecision == "chase" ? 0.9 : 1.0))
    {
        newDecision = "chase";
        color = 0x00FF00FF;
    }
    else if (angleIsGood)
    {
        newDecision = "kick";
        color = 0xFF0000FF;
    }
    else
    {
        newDecision = "adjust";
        color = 0x00FFFFFF;
    }

    setOutput("decision_out", newDecision);
    brain->log->logToScreen("tree/Decide",
                            format("Decision: %s ballrange: %.2f ballyaw: %.2f kickDir: %.2f rbDir: %.2f angleIsGood: %d", newDecision.c_str(), ballRange, ballYaw, kickDir, dir_rb_f, angleIsGood),
                            color);
    return NodeStatus::SUCCESS;
}

tuple<double, double, double> Kick::_calcSpeed() {
    double vx, vy, msecKick;


    double vxLimit, vyLimit;
    getInput("vx_limit", vxLimit);
    getInput("vy_limit", vyLimit);
    int minMSecKick;
    getInput("min_msec_kick", minMSecKick);
    double vxFactor = brain->config->vxFactor;   
    double yawOffset = brain->config->yawOffset; 


    double adjustedYaw = brain->data->ball.yawToRobot + yawOffset;
    double tx = cos(adjustedYaw) * brain->data->ball.range; 
    double ty = sin(adjustedYaw) * brain->data->ball.range;

    if (fabs(ty) < 0.01 && fabs(adjustedYaw) < 0.01)
    { 
        vx = vxLimit;
        vy = 0.0;
    }
    else
    { 
        vy = ty > 0 ? vyLimit : -vyLimit;
        vx = vy / ty * tx * vxFactor;
        if (fabs(vx) > vxLimit)
        {
            vy *= vxLimit / vx;
            vx = vxLimit;
        }
    }


    double speed = norm(vx, vy);
    msecKick = speed > 1e-5 ? minMSecKick + static_cast<int>(brain->data->ball.range / speed * 1000) : minMSecKick;
    
    return make_tuple(vx, vy, msecKick);
}

NodeStatus Kick::onStart()
{
    _minRange = brain->data->ball.range;
    _speed = 0.5;
    _startTime = brain->get_clock()->now();


    bool avoidPushing;
    double kickAoSafeDist;
    brain->get_parameter("obstacle_avoidance.avoid_during_kick", avoidPushing);
    brain->get_parameter("obstacle_avoidance.kick_ao_safe_dist", kickAoSafeDist);
    string role = brain->tree->getEntry<string>("player_role");
    if (
        avoidPushing
        && (role != "goal_keeper")
        && brain->data->robotPoseToField.x < brain->config->fieldDimensions.length / 2 - brain->config->fieldDimensions.goalAreaLength
        && brain->distToObstacle(brain->data->ball.yawToRobot) < kickAoSafeDist
    ) {
        brain->client->setVelocity(-0.1, 0, 0);
        return NodeStatus::SUCCESS;
    }

    // 发布运动指令
    double angle = brain->data->ball.yawToRobot;
    brain->client->crabWalk(angle, _speed);
    return NodeStatus::RUNNING;
}

NodeStatus Kick::onRunning()
{
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/Kick", rerun::TextLog(msg));
    };


    bool enableAbort;
    brain->get_parameter("strategy.abort_kick_when_ball_moved", enableAbort);
    auto ballRange = brain->data->ball.range;
    const double MOVE_RANGE_THRESHOLD = 0.3;
    const double BALL_LOST_THRESHOLD = 1000;  
    if (
        enableAbort 
        && (
            (brain->data->ballDetected && ballRange - _minRange > MOVE_RANGE_THRESHOLD) 
            || brain->msecsSince(brain->data->ball.timePoint) > BALL_LOST_THRESHOLD 
        )
    ) {
        log("ball moved, abort kick");
        return NodeStatus::SUCCESS;
    }


    if (ballRange < _minRange) _minRange = ballRange;    

    
    bool avoidPushing;
    brain->get_parameter("obstacle_avoidance.avoid_during_kick", avoidPushing);
    double kickAoSafeDist;
    brain->get_parameter("obstacle_avoidance.kick_ao_safe_dist", kickAoSafeDist);
    if (
        avoidPushing
        && brain->data->robotPoseToField.x < brain->config->fieldDimensions.length / 2 - brain->config->fieldDimensions.goalAreaLength
        && brain->distToObstacle(brain->data->ball.yawToRobot) < kickAoSafeDist
    ) {
        brain->client->setVelocity(-0.1, 0, 0);
        return NodeStatus::SUCCESS;
    }


    double msecs = getInput<double>("min_msec_kick").value();
    double speed = getInput<double>("speed_limit").value();
    msecs = msecs + brain->data->ball.range / speed * 1000;
    if (brain->msecsSince(_startTime) > msecs) { 
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }


    if (brain->data->ballDetected) { 
        double angle = brain->data->ball.yawToRobot;
        double speed = getInput<double>("speed_limit").value();
        _speed += 0.1; 
        speed = min(speed, _speed);
        brain->client->crabWalk(angle, speed);
    }

    return NodeStatus::RUNNING;
}

void Kick::onHalted()
{
    _startTime -= rclcpp::Duration(100, 0);
}

NodeStatus StandStill::onStart()
{

    _startTime = brain->get_clock()->now();


    brain->client->setVelocity(0, 0, 0);
    return NodeStatus::RUNNING;
}

NodeStatus StandStill::onRunning()
{
    double msecs;
    getInput("msecs", msecs);
    if (brain->msecsSince(_startTime) < msecs) {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::RUNNING;
    }


    return NodeStatus::SUCCESS;
}

void StandStill::onHalted()
{
    double msecs;
    getInput("msecs", msecs);
    _startTime -= rclcpp::Duration(- 2 * msecs, 0);
}


NodeStatus RobotFindBall::onStart()
{
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/RobotFindBall", rerun::TextLog(msg));
    };
    log("RobotFindBall onStart");

    if (brain->data->ballDetected)
    {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }
    _turnDir = brain->data->ball.yawToRobot > 0 ? 1.0 : -1.0;

    return NodeStatus::RUNNING;
}

NodeStatus RobotFindBall::onRunning()
{
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/RobotFindBall", rerun::TextLog(msg));
    };
    log("RobotFindBall onRunning");

    if (brain->data->ballDetected)
    {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    double vyawLimit;
    getInput("vyaw_limit", vyawLimit);

    double vx = 0;
    double vy = 0;
    double vtheta = 0;
    if (brain->data->ball.range < 0.3)
    { 
      // vx = cap(-brain->data->ball.posToRobot.x, 0.2, -0.2);
      // vy = cap(-brain->data->ball.posToRobot.y, 0.2, -0.2);
    }
    // vtheta = _turnDir > 0 ? vyawLimit : -vyawLimit;
    brain->client->setVelocity(0, 0, vyawLimit * _turnDir);
    return NodeStatus::RUNNING;
}

void RobotFindBall::onHalted()
{
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/RobotFindBall", rerun::TextLog(msg));
    };
    log("RobotFindBall onHalted");
    _turnDir = 1.0;
}

NodeStatus CamFastScan::onStart()
{
    _cmdIndex = 0;
    _timeLastCmd = brain->get_clock()->now();
    brain->client->moveHead(_cmdSequence[_cmdIndex][0], _cmdSequence[_cmdIndex][1]);
    return NodeStatus::RUNNING;
}

NodeStatus CamFastScan::onRunning()
{
    double interval = getInput<double>("msecs_interval").value();
    if (brain->msecsSince(_timeLastCmd) < interval) return NodeStatus::RUNNING;

    // else 
    if (_cmdIndex >= 6) return NodeStatus::SUCCESS;

    // else
    _cmdIndex++;
    _timeLastCmd = brain->get_clock()->now();
    brain->client->moveHead(_cmdSequence[_cmdIndex][0], _cmdSequence[_cmdIndex][1]);
    return NodeStatus::RUNNING;
}

NodeStatus TurnOnSpot::onStart()
{
    _timeStart = brain->get_clock()->now();
    _lastAngle = brain->data->robotPoseToOdom.theta;
    _cumAngle = 0.0;

    bool towardsBall = false;
    _angle = getInput<double>("rad").value();
    getInput("towards_ball", towardsBall);
    if (towardsBall) {
        double ballPixX = (brain->data->ball.boundingBox.xmin + brain->data->ball.boundingBox.xmax) / 2;
        _angle = fabs(_angle) * (ballPixX < brain->config->camPixX / 2 ? 1 : -1);
    }

    brain->client->setVelocity(0, 0, _angle, false, false, true);
    return NodeStatus::RUNNING;
}

NodeStatus TurnOnSpot::onRunning()
{
    double curAngle = brain->data->robotPoseToOdom.theta;
    double deltaAngle = toPInPI(curAngle - _lastAngle);
    _lastAngle = curAngle;
    _cumAngle += deltaAngle;
    double turnTime = brain->msecsSince(_timeStart);
    // brain->log->log("debug/turn_on_spot", rerun::TextLog(format(
    //     "angle: %.2f, cumAngle: %.2f, deltaAngle: %.2f, time: %.2f",
    //     _angle, _cumAngle, deltaAngle, turnTime
    // )));
    if (
        fabs(_cumAngle) - fabs(_angle) > -0.1
        || turnTime > _msecLimit
    ) {
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    // else 
    brain->client->setVelocity(0, 0, (_angle - _cumAngle)*2);
    return NodeStatus::RUNNING;
}

NodeStatus MoveToPoseOnField::tick()
{
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/Move", rerun::TextLog(msg));
    };
    log("Move ticked");

    double tx, ty, ttheta, longRangeThreshold, turnThreshold, vxLimit, vyLimit, vthetaLimit, xTolerance, yTolerance, thetaTolerance;
    getInput("x", tx);
    getInput("y", ty);
    getInput("theta", ttheta);
    getInput("long_range_threshold", longRangeThreshold);
    getInput("turn_threshold", turnThreshold);
    getInput("vx_limit", vxLimit);
    getInput("vx_limit", vxLimit);
    getInput("vy_limit", vyLimit);
    getInput("vtheta_limit", vthetaLimit);
    getInput("x_tolerance", xTolerance);
    getInput("y_tolerance", yTolerance);
    getInput("theta_tolerance", thetaTolerance);
    bool avoidObstacle;
    getInput("avoid_obstacle", avoidObstacle);

    brain->client->moveToPoseOnField2(tx, ty, ttheta, longRangeThreshold, turnThreshold, vxLimit, vyLimit, vthetaLimit, xTolerance, yTolerance, thetaTolerance, avoidObstacle);
    return NodeStatus::SUCCESS;
}

NodeStatus GoToReadyPosition::tick()
{
    auto log = [=](string msg) {
        // brain->log->setTimeNow();
        // brain->log->log("debug/GoToReadyPosition", rerun::TextLog(msg));
    };
    log("GoToReadyPosition ticked");

    double distTolerance, thetaTolerance;
    getInput("dist_tolerance", distTolerance);
    getInput("theta_tolerance", thetaTolerance);
    string role = brain->tree->getEntry<string>("player_role");
    bool isKickoff = brain->tree->getEntry<bool>("gc_is_kickoff_side");
    auto fd = brain->config->fieldDimensions;


    double tx = 0, ty = 0, ttheta = 0; 
    double longRangeThreshold = 1.0;
    double turnThreshold = 0.4;
    double vxLimit, vyLimit;
    getInput("vx_limit", vxLimit);
    getInput("vy_limit", vyLimit);
    if (brain->distToBorder() > - 1.0) { 
        vxLimit = 0.5;
        vyLimit = 0.3;
    }
    double vthetaLimit = 1.3;
    bool avoidObstacle = true;

    if (role == "striker" && isKickoff) {
        tx = - max(fd.circleRadius, 1.5);
        ty = 0;
        if (brain->config->numOfPlayers == 3 && brain->data->liveCount >= 2)
        {
            if (brain->isPrimaryStriker()) {
                ty = 1.5;
            } else {
                ty = -1.5;
            }
        }
        ttheta = 0;
    } else if (role == "striker" && !isKickoff) {
        tx = - fd.circleRadius * 1.0;
        ty = 0;
        if (brain->config->numOfPlayers == 3 && brain->data->liveCount >= 2)
        {
            if (brain->isPrimaryStriker()) {
                ty = 1.5;
            } else {
                ty = -1.5;
            }
        }
        ttheta = 0;
    } else if (role == "goal_keeper") {
        tx = -fd.length / 2.0 + fd.goalAreaLength;
        ty = 0;
        ttheta = 0;
    }

    brain->client->moveToPoseOnField2(tx, ty, ttheta, longRangeThreshold, turnThreshold, vxLimit, vyLimit, vthetaLimit, distTolerance / 1.5, distTolerance / 1.5, thetaTolerance, avoidObstacle);
    return NodeStatus::SUCCESS;
}

NodeStatus GoBackInField::tick()
{
    auto log = [=](string msg) {
        brain->log->setTimeNow();
        brain->log->log("debug/GoBackInField", rerun::TextLog(msg));
    };
    log("GoBackInField ticked");

    double valve;
    getInput("valve", valve);
    double vx = 0; 
    double vy = 0; 
    double dir = 0;
    auto fd = brain->config->fieldDimensions;
    if (brain->data->robotPoseToField.x > fd.length / 2.0 - valve) dir = - M_PI;
    else if (brain->data->robotPoseToField.x < - fd.length / 2.0 + valve) dir = 0;
    else if (brain->data->robotPoseToField.y > fd.width / 2.0 + valve) dir = - M_PI / 2.0;
    else if (brain->data->robotPoseToField.y < - fd.width / 2.0 - valve) dir = M_PI / 2.0;
    else { 
        brain->client->setVelocity(0, 0, 0);
        return NodeStatus::SUCCESS;
    }

    
    double dir_r = toPInPI(dir - brain->data->robotPoseToField.theta);
    vx = 0.4 * cos(dir_r);
    vy = 0.4 * sin(dir_r);
    brain->client->setVelocity(vx, vy, 0, false, false, false);
    return NodeStatus::SUCCESS;
}

NodeStatus WaveHand::tick()
{
    string action;
    getInput("action", action);
    if (action == "start")
        brain->client->waveHand(true);
    else
        brain->client->waveHand(false);
    return NodeStatus::SUCCESS;
}

NodeStatus MoveHead::tick()
{
    double pitch, yaw;
    getInput("pitch", pitch);
    getInput("yaw", yaw);
    brain->client->moveHead(pitch, yaw);
    return NodeStatus::SUCCESS;
}

NodeStatus CheckAndStandUp::tick()
{
    if (brain->tree->getEntry<bool>("gc_is_under_penalty") || brain->data->currentRobotModeIndex == 1) {
        brain->data->recoveryPerformedRetryCount = 0;
        brain->data->recoveryPerformed = false;
        brain->log->log("recovery", rerun::TextLog("reset recovery"));
        return NodeStatus::SUCCESS;
    }
    brain->log->log("recovery", rerun::TextLog(format("Recovery retry count: %d, recoveryPerformed: %d recoveryState: %d currentRobotModeIndex: %d", brain->data->recoveryPerformedRetryCount, brain->data->recoveryPerformed, brain->data->recoveryState, brain->data->currentRobotModeIndex)));

    if (!brain->data->recoveryPerformed &&
        brain->data->recoveryState == RobotRecoveryState::HAS_FALLEN &&
        // brain->data->isRecoveryAvailable && 
        brain->data->currentRobotModeIndex == 3 && 
        brain->data->recoveryPerformedRetryCount < brain->get_parameter("recovery.retry_max_count").get_value<int>()) {
        brain->client->standUp();
        brain->data->recoveryPerformed = true;
        brain->speak("Trying to stand up");
        brain->log->log("recovery", rerun::TextLog(format("Recovery retry count: %d", brain->data->recoveryPerformedRetryCount)));
        return NodeStatus::SUCCESS;
    }

    if (brain->data->recoveryPerformed && brain->data->currentRobotModeIndex == 12) {
        brain->data->recoveryPerformedRetryCount +=1;
        brain->data->recoveryPerformed = false;
        brain->log->log("recovery", rerun::TextLog(format("Add retry count: %d", brain->data->recoveryPerformedRetryCount)));
    }


    if (brain->data->recoveryState == RobotRecoveryState::IS_READY &&
        brain->data->currentRobotModeIndex == 8) { 
        brain->data->recoveryPerformedRetryCount = 0;
        brain->data->recoveryPerformed = false;
        brain->log->log("recovery", rerun::TextLog("Reset recovery, recoveryState: " + to_string(static_cast<int>(brain->data->recoveryState))));
    }

    return NodeStatus::SUCCESS;
}


NodeStatus CalibrateOdom::tick()
{
    double x, y, theta;
    getInput("x", x);
    getInput("y", y);
    getInput("theta", theta);

    brain->calibrateOdom(x, y, theta);
    return NodeStatus::SUCCESS;
}

NodeStatus PrintMsg::tick()
{
    Expected<std::string> msg = getInput<std::string>("msg");
    if (!msg)
    {
        throw RuntimeError("missing required input [msg]: ", msg.error());
    }
    std::cout << "[MSG] " << msg.value() << std::endl;
    return NodeStatus::SUCCESS;
}

NodeStatus PlaySound::tick()
{
    string sound;
    getInput("sound", sound);
    bool allowRepeat;
    getInput("allow_repeat", allowRepeat);
    brain->playSound(sound, allowRepeat);
    return NodeStatus::SUCCESS;
}

NodeStatus Speak::tick()
{
    const string lastText;
    string text;
    getInput("text", text);
    if (text == lastText) return NodeStatus::SUCCESS;

    brain->speak(text, false);
    return NodeStatus::SUCCESS;
}
